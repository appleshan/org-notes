Dubbo 集群特性分析介绍

Dubbo 在集群上有这样的一些特性：容错性，负载均衡，访问规则。支持各种主流的远程访问协议。

* 容错性

当客户端访问服务端的时候，服务端出错或者网络出现问题，都会使得远程访问失败，失败
是不可避免的，所以 Dubbo 制定了一些失败补偿策略给开发者使用，主要有如下的策略：

** 1、重试

失败自动切换，当出现失败，重试其它服务器。(缺省)。

通常用于读操作，但重试会带来更长延迟。
可通过 retries=”2″来设置重试次数(不含第一次)

** 2、快速失败

快速失败，只发起一次调用，失败立即报错。

通常用于非幂等性的写操作，比如新增记录。

** 3、失败安全

失败安全，出现异常时，直接忽略。

通常用于写入审计日志等操作。

** 4、定时重发

失败自动恢复，后台记录失败请求，定时重发。

通常用于消息通知操作。

** 5、并行调用

并行调用多个服务器，只要一个成功即返回。

通常用于实时性要求较高的读操作，但需要浪费更多服务资源。
可通过 forks=”2″来设置最大并行数。

* 负载均衡

作为一个具有分布式和集群的框架，当访问数量上来的时候，不可避免的要使用负载来降低
单个服务端的压力。主要采用了如下的负载算法来实现负载均衡。

** 1、随机

随机，按权重设置随机概率。

在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，
有利于动态调整提供者权重。

** 2、轮询

轮循，按公约后的权重设置轮循比率。

存在慢的提供者累积请求问题，
比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，
久而久之，所有请求都卡在调到第二台上。

** 3、最少活跃度

最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。

使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

** 4、一致性哈希

一致性 Hash，相同参数的请求总是发到同一提供者。

当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会
引起剧烈变动。

算法参见：http://en.wikipedia.org/wiki/Consistent_hashing。

缺省只对第一个参数 Hash，如果要修改，请配置<dubbo:parameter key=”hash.arguments” value=”0,1″ />

缺省用 160 份虚拟节点，如果要修改，请配置<dubbo:parameter key=”hash.nodes” value=”320″ />

* 访问规则

对于一些有需要特定访问路径的应用，Dubbo 提供了访问规则这个功能，给开发者根据具体
的需求编写特定的访问规则逻辑。

** 1、地址过滤，功能级别的访问规则，用户在应用中或者管理中心配置就可以提供。

排除

白单

黑单

读写分离

前后台分离

网段隔离

** 2、脚本规则，用动态语言设计具体的访问规则，灵活度最高。

javascript

jruby

groovy

** 3、配置规则，也是一种规则制定的方式。

禁用提供者

调整权重

负载均衡

服务降级

* 访问协议

支持主流的远程访问协议，开发者可以根据自己项目的情况选择一种合适的访问协议。

** Dubbo(缺省)
默认使用的协议，也是框架推荐的。实现上使用了 Netty 做通信，使用 NIO 异步同行，用
 Hessian 做序列化和反序列化，适合常规的远程方法调用，小于 100K 的数据传输，不适合
大数据的传输。约束是是返回值必须实现 Serializable 接口，返回值需要有无构造函数。

** RMI
阻塞式的短连接，JDK 标准序列化，JDK 标准方式访问，好处就两个字<标准>。

** Hession
基于 Http 协议，使用 Jetty 容器，可与原生的 Hession 服务端进行互操作。

** WebService
基于 CXF 的实现，也是标准，好处是方便异构语言的通信，不足是性能较差。

** Memcached 和 Redis
注册服务，基于 K,V 方式的调用

